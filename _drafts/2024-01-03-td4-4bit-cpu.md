---
layout: post
title: TD4 4-bit CPU
---

It seems like there is a japanese book about this thing but I can't find a translation

Examining the schematic, looks like there is no ram to speak of, so this is a very limited machine. A + B + OUT + PC means there is 16 bits of state? Can easily exhaustively check this for anything you'd like. What about synthesizing programs?
Maybe this is good though
This is so constrained it feels more like a finite state machine.
Try model checking it?

Could I implement in python hdl or verilog or that gui thing?

Didn't Conor Macbride have a 4 bit cpu videos?
Are there actually 4-bit cpu ou there like this?

<https://en.wikipedia.org/wiki/4-bit_computing>

What interesting programs can be written? Toughy.

Model each chip

```verilog
module ALU()

end

module ROM()
end


`def JMP 0

module Computron()
    reg [3:0] A;
    reg [3:0] B;
    reg [3:0] OUT;
    reg [3:0] PC;
    

end
```

74HC154 - Address decoder - 4 - 16 line decoder / demultiplexer. The four incoming signals are translated to 16 mutually exclusive outputs. For example in the inputs pins are LLHH will draw pin 3 of the output _low_.  Because of all the diodes, only current will flow in through the ROM switches when that bank is enabled by bing drawn low

The two enable pins are drawn down to ground so that output is always enabled.

The lines come into this decode and select which flipy floppr is drawn

74HC540 is an inverting buffer.

![](https://github.com/wuxx/TD4-4BIT-CPU/blob/master/doc/PCB/kit1.jpg?raw=true)
![](https://github.com/wuxx/TD4-4BIT-CPU/blob/master/doc/cpu_td4.jpg?raw=true)

<https://github.com/wuxx/TD4-4BIT-CPU>

<https://en.wikipedia.org/wiki/Charlieplexing> Are all these diodes chaliplexed?

<https://hackaday.io/project/8442-ttl-based-4-bit-cpu>
<https://hackaday.io/project/26215-td4-cpu>
<http://kamakurium.com/wp-content/uploads/2016/01/cpu_td4>
<http://visual6502.org/>
<http://www.4004.com/>

Experiment we ran:

1. output two diffrent immediate to out, jmp 0
out 1001
out 0110
jmp 0

2. count up

add b 1
out b
jmp 0

3. count down
require realizing modular arithemtic
add b 15
out b
jmp 0

4. count up and down

Mistakes we made
we fed will ice cream too early.
We flipped the labels going into JNC vs JMP
We had the OUT in places they couldn't be executed (at the bottom of the program)
We moved OUT after the add, destroying the carry for ADD A 1
We realized we should think of ADD B 1, OUT B a a single unit
And in fact after examing the circuit, thee two can be compressed to OUT B 1 because OUT actually takes immiedates. We lucked out that we zeroed the immedates on MOV and OUT.

Remember the program counter was 0 indexed

ADD B 1     1000 1010
OUT B       xxxx 1001
MOV A B     xxxx 1000
ADD A 1     1000 0000
JNC 0       0000 0111
ADD B 15    1111 1010
OUT B       xxxx 1001
MOV A B     xxxx 1000
ADD A 15    1111 0000
JNC 0       0000 0111
JMP 5       0110 1111

add b 1
jnc 3
jmp 5
out b
jmp 0
mov b 15
add b 15
jnc 0
out b
jmp 6

ADD B 1     1000 1010
OUT B       xxxx 1001
MOV A B     xxxx 1000
ADD A 1     1000 0000
JNC 0       0000 0111
ADD B 15    1111 1010
OUT B       xxxx 1001
MOV A B     xxxx 1000
ADD A 15    1111 0000
JNC 0       0000 0111
JMP 5       0110 1111

A different version. Using tthe idea JC ~ JNC;JMP

Ben Wiener, 30 min
ADD B 1
JNC 3
JMP 5
OUT B
JMP 0
MOV B 15
ADD B 15
JNC 0
OUT B
JMP 6
