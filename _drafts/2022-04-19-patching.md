---
date: 2022-04-14
layout: post
title: "Program Patching and Dwarf"
tags: binary analysis dwarf
description:
---

At work we've been been tinkering away on [VIBES](https://github.com/draperlaboratory/VIBES) for over a year at this point. VIBES is a parto of the [DARPA Assured Micropatching](https://www.darpa.mil/program/assured-micropatching) (AMP) program. We've been building a neat minizinc constraint based patching compiler that deserves many blog posts of it's own.

Something that has driven me insane with despair during this program is how to precisely talk about the connection between high and low level code in a way that allows for patching.

In a naive picture of what a compiler does, it looks at programs chunk by chunk and outputs some assembly tha corresponds in a reasonable way to that code. Maybe `foo` goes in `R0`, `bar` goes on the stack, etc. This assignment becomes a `mov` here, this addition expression becomes an `add` here.

This is a completely false picture and banish it from your mind.

High level programs are _delusions_. Optimizing compilers make surprisingly few guarantees about what what state correspondences must exist between high and low level code. They may inline code, reorder assignments, rematerialize and copy variables, fuse loops.

The main thing they try to guarantee is that the high and low level code should have the same [observable behavior](https://en.cppreference.com/w/cpp/language/as_if). This amounts to some memory access, IO and some function calls must actually happen.

I can't deny however, that despite the compiler guaranteeing correspondence of high and low at specific points in limited ways, it just so happens that we can usually intuitively see that this region of assembly vaguely corresponds to this region of high level code, and that this high level variable here is stored in that low level variable there. So how is one supposed to proceed when there is clearly an intuitive correspondence that you need precise enough to post hoc patch in code? How do you even describe this correspondence? What is the schema of this correspondence?


It so happens that our task is not to post hoc patch the original source, but decompiled source, say by Ghidra of Binary Ninja. This task is perhaps a bit easier than the optimizing compiler case because the goal of a decompiler is to keep the correspondence understandable. The goal of an optimizing compiler one might say is the exact opposite. It wishes to mangle code as much as it can to eke out performance. The goal of optimizing compiler writers is to make my life hell and I take it personally.

This topic is related to that of concurrency. In concurrent code, there is a window by which other processes see things that were never meant to be seen. At minimum, intermediate states of shared variables become observable. Reads and writes to these variables may no longer be reorder or inlined or done in pieces and maintain the intent of the code. The was crisis of sorts when people started realizing that the mechanisms they vaguely felt made sense, didn't actually make sense in concurrent situations. Straightening this out was quite a lot of work (See memory models).

I've heard it described that one way to think about the concurrency problem is to think of concurrent code as having sort of a debugger level view of the assembly. Debugging is actually a very interesting thing to examine for this problem. Debugging info tries to maintain the connection between high and low data in such away as to be understandable enough to a human operator.

DWARF is a standardized ubiquitous debugging format. It is expressive and open ended. It structured and tree like, kind of like XML or JSON (variables are scoped in subprograms which are scope in compilation units for example).

```C
int main(int argc){
    int i = argc * 2 + 7;
    return i;
}
```
You can see dwarf data by compiling a program with `-g` and using `readelf`

```sh
gcc -g main.c
readelf --debug-dump a.out
```

Show dwarf sections here

DWARF has built in ways to talk about
- Stack frames
- Variables and their locations
- Type information
- Source line and column numbers corresponding to addresses (the line table)


VIBES works on JSON config files that describe the patches. We've sort of grown this config file as the need has arised to get at th information we need in the most direct way possible. It has not been desirable to spend months pondering what is the most general way to describe the relationship between high and low. In fact, it is my belief that this is not how problems are solved anyway. You solve problems by working at it and seeing what you learn.

Here's an example config json for a [simple patch](https://github.com/draperlaboratory/VIBES/tree/main/resources/exes/arm-null-check).

- A comparative SMTLIB specification for correct patch behavior
- `patch-point` describes the address at which to hijack control flow into our code
- `patch-size` implicitly describe both dead code (the region between `patch-point` and `patch-point + patch-size`) and also where to fallthrough from out patch code.
- `patch-vars` describes what variables can be read from where in the `at-entry` field and where they need to be in the `at-exit` field.

```json
{
  "max-tries": 10,
  "wp-params": {
    "func": "patch_fun",
    "postcond": "(assert
  (implies
    (and (= init_mem_orig init_mem_mod)
         (bvugt init_R0_orig init_SP_orig)
         (= init_R0_orig init_R0_mod))
    (ite (= init_R0_mod #x00000000)
      (= R0_mod #xffffffff)
      (and (= R0_mod R0_orig)
           (= R0_mod
              (concat
                (select init_mem_mod (bvadd init_R0_mod #x00000003))
                (select init_mem_mod (bvadd init_R0_mod #x00000002))
                (select init_mem_mod (bvadd init_R0_mod #x00000001))
                (select init_mem_mod init_R0_mod)))))))"
  },
  "patches": [
    {"patch-name": "null-check",
     "patch-code": "int *x, retval;
                    retval = x ? *x : -1;",
     "patch-point": "0x10468",
     "patch-size": 36,
     "patch-vars": [
       {"name": "x",
        "at-entry": "R0",
        "at-exit": "R0"
       }
     ],
     "extra-constraints": "
       % exclude callee-save registers from the solution
       constraint exclude_reg('R4');
       constraint exclude_reg('R5');
       constraint exclude_reg('R6');
       constraint exclude_reg('R7');
       constraint exclude_reg('R8');
       constraint exclude_reg('R9');
       constraint exclude_reg('R10');
       constraint exclude_reg('R11');
       constraint exclude_reg('SP');
     "
    }
  ]
}
```


I think that we can use already existent DWARF DIEs to approximate or improve these fields.

- `DW_TAG_variable` `DW_TAG_formal_parameter` are two DIEs that describe variables. They have attributes. This is similar to our `patch-vars` field. It is both more and less expressive
- `DW_TAG_label` seems like a reasonable choice to encode both the patch entry and patch exit points. It is very possibly for a patch to have multiple exits (and maybe multiple entries?) so it would be nice for a human to be able to annotate these points in the high level code which we could then read off. 
- `DW_TAG_lexical_block` gives us a way to talk about regions in the high code. We can use this to describe what code we are replacing, i.e. deadcode.
- DWARF type descriptors


# Extensions to DWARF
"The" relationship between high variables and low variables is multivalued, partial, and address dependent. I suspect that even the very language I am using here leads to false thinking. I don't even think there _is_ a single "correspondence" relationship between high and low variables but instead many.

What about "the" relationship addresses and high level program points? This is also very scattered by the rearrangement of statements of the high level code. This relationship is also partial, multivalued, and does not transfer nicely along the control flow of either.

In fact I think this is the wrong way to talk about the problem.



## Program Analysis












But today we're gonna talk about DWARF.


Patch Expansion
Writing DWARF
Watching the patch being made. Edit sequences.


Two projects which certainly have to tackle a concrete notion of the relation between high and low are Compcert and sel4.
https://www.cs.cmu.edu/~15811/papers/compcert-journal.pdf

recompilation

Thanks to Chris Casinghino, Cody Roux, JT Paasch, Ben Mourad, Ivan Gotovchits, Chloe Fortuna, AMP, Sergey Bratus. Any ideas that are bad herein I claim as my ow.

