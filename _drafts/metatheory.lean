


example (x y : Nat) : x + y = y + x := by
  rw [Nat.add_comm]


def main : IO Unit := return ()

/-
model thoery

finite subsets of formulas to models

Finstruct

cerosible up arrow

nonempty

choice : Nonempty T -> T

hint (hint)

What would be something simpler to do with thi

finite model of a group

database? |=

![x,y] : Fin n -> x
overspill = transfer

suffices


pra
dialectica in coq
proof mning in lean

rca0. you don't have iduction



bhk interrpetation

tarski
interp (And a b) = interp a /\ interp b

Instead we need to define a notion of programs
inductive program
| and
| or


They could be turing machines.
They could

run : program -> evidence -> bool

Enumerable sets. What does that mean? We need a particular language we're wroking in
Computable functions. What does that mean?
If we have an signature extension, then there is a natrual notion of comparing theories,
but otherwise we really need to define what it means to compare two systems

Systems are already comparable in that they live in the same metalogic (lean)

And they can be compared via the lean intermediary if you've given them semantics in lean

If you bottow your host powers, you kind of don't know what you're borrowing
That's the beauty and danger of it








-/
